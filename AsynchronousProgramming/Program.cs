

using AsynchronousProgramming;
using System.Reflection.PortableExecutable;

//var dc = new DivideAndConquer();
//dc.Demo();

//var tc = new TaskContinuationDemo();
//tc.Demo();
//tc.GetPokemon();
//tc.GetPokemonContinueWith();
//tc.GetPokemonContinueWithChain();

//var ex = new ExceptionHandling();
//ex.Demo();
//await ex.DemoExceptionHandling();
//ex.DemoExceptionThrow();

//var sp = new SemaphoreDemo();
//sp.Demo();

//var tn = new TaskCancellationDemo();
//tn.Demo();
//tn.DemoCancelAfter();

//var aa = new AsyncAwait();
//aa.Demo();
//await aa.DemoAwait();

//var tw = new TaskContinuationAwait();
//await tw.Demo();

//var pl = new ParallelLoops();
//pl.Demo();
//pl.DemoParallelInvoke();
//pl.GetType();
//pl.DemoStop();
//pl.DemoBreak();
//pl.DemoCancel();
//pl.DemoThreadLocalStorage();

//var pq = new PLinq();
//pq.Demo();
//pq.DemoExceptionHandling();
//pq.DemoCancellation();

//var cq = new ConcurrentQueueDemo();
//cq.Demo();

//var cs = new ConcurrentStackDemo();
//cs.Demo();

var bc = new BlockingCollectionDemo();
bc.Demo();